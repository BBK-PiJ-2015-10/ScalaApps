import akka.actor._
import CoffeeProtocol._
import CoffeeProtocol.Uninitialised

class CoffeeShop extends FSM[State,Data] {
  
  startWith(Closed,Uninitialised)
  
  when(Closed) {
    
    case Event(Open, _) =>
     
      context.actorOf(Props[Barrister], "john")
      context.actorOf(Props[Barrister], "maria")
      context.actorOf(Props[Barrister], "james")
      context.actorOf(Props[Barrister], "the-one-with-the-hipster-beard")
      goto (Opened) using OrderQueue(Map.empty)

   
    case Event(Barristas, _) =>
      
      println(context.children)
      //sender ! context.chilren
      stay
      
  }
  
  when (Opened) {
    
    case Event(CustomerOrder(name), o@OrderQueue(q)) =>
      val barrista = getNextAvailableBarrista
      barrista.tell(CustomerOrder(name),self)
      sender.tell(Info("I will be making your coffee today"),barrista)
      stay using o.copy(queue = q + (barrista -> name))
    
    case Event(Coffee(name), o@OrderQueue(q)) =>
      log.info(s"Got coffee back from ${sender.path.name}")
      val newQueue = q - sender
      stay using o.copy(queue = newQueue)
    
    case Event(Barristas, _) =>
      sender ! context.children
      stay
    
    case Event(Queue, o@OrderQueue(q)) =>
      sender ! q
      stay
  }
  
  
  onTransition {
    
    case _ -> Opened =>
      log.info("Transitioning to Active")
      
    case _ -> Closed =>
      log.info("Transitioning to IDLE")
      context.children.foreach {
        _ ! PoisonPill
      }
    
  }
  
  def getNextAvailableBarrista: ActorRef = {
    stateData match {
      case OrderQueue(m) =>
        context.children.filterNot(c=>m.keys.toList.contains(c)).head
      case Uninitialised =>
        scala.util.Random.shuffle(context.children).head
    }
  }
  
  
  initialize()
  
}